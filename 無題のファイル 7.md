---
tags: ""
datetimeCreate: 2025-06-30 22:13
---

はい、データが正常に取得できるようになった原因を詳しく解説しますね。

一言で言うと、**「サーバーサイドのページからAPIを呼び出す際に、認証情報（Cookie）が正しくAPI側に伝わっていなかった」**のが根本的な原因です。

手紙に例えると、APIという宛先に「手紙（リクエスト）」を送る際、**「本人確認のための合言葉（認証トークン）」を封筒の正しい場所に書いていなかった**ため、門前払いされていた状態でした。

---

### 発生していた問題の詳細

#### 1. サーバーサイド`fetch`の課題（手紙の書き方の問題）

サーバーサイドのコンポーネント（`page.tsx`）から`fetch`を使ってAPIを呼び出すとき、ブラウザが自動で行ってくれるような「Cookieの添付」は行われません。手動で設定する必要がありましたが、その方法が不十分でした。

-   **当初のコード**: `Cookie`ヘッダーに`cookieStore.toString()`を設定していましたが、これはNext.jsの内部的な表現であり、APIが`NextRequest`として受け取った際に正しく解釈できない場合がありました。
-   **途中の試み**: `X-Request-Source`のようなカスタムヘッダーを追加しましたが、これも根本的なCookieの受け渡し問題を解決するには至りませんでした。

#### 2. APIエンドポイントの課題（手紙の受け取り方の問題）

APIエンドポイント（`route.ts`）側も、サーバーから送られてくる特殊な形式のリクエストからCookieを読み取るのに苦労していました。

-   **当初のコード**: `request.headers.get('Cookie')`でヘッダー文字列を取得し、そこから正規表現でトークンを抜き出そうと試みましたが、これは非常に不安定な方法でした。
-   **問題点**: サーバーからの`fetch`と、ブラウザからの通常の`fetch`とで、`NextRequest`オブジェクトの内部構造が微妙に異なり、一貫したトークンの取得が難しくなっていました。

---

### 最終的な解決策

この「手紙のやり取り」を成功させるために、**送り手と受け取り手の両方でルールを統一**しました。

#### 1. `page.tsx`の修正（送り手の改善）

「封筒に合言葉を正しく書く」ために、Cookie文字列を手動で丁寧に構築しました。

```typescript
// page.tsx

// 1. 全てのCookieを取得
const cookieStore = await cookies();

// 2. 「key=value; key2=value2」形式の標準的な文字列に変換
const cookieString = cookieStore.getAll().map(c => `${c.name}=${c.value}`).join('; ');

// 3. fetchリクエストのヘッダーに設定
const requestHeaders = new Headers();
requestHeaders.set('Cookie', cookieString);

const response = await fetch(url, { headers: requestHeaders });
```

これにより、API側が確実に解釈できる形式で認証情報が送られるようになりました。

#### 2. `route.ts`の修正（受け取り手の改善）

「封筒のどこを見れば合言葉が書いてあるか知っている」賢い受け取り手になるため、Next.jsの標準的なAPIを使うようにしました。

```typescript
// route.ts (API側)

// サーバー・クライアント問わず、この方法で確実にCookieを読み取れる
const accessToken = request.cookies.get('sb-access-token')?.value;
```

`request.headers`から無理やり取り出すのではなく、`request.cookies`という専用のAPIを使うことで、Next.jsが内部的な差異を吸収してくれ、どんなリクエストからでも安定してCookieの値を取得できるようになったのです。

---

### まとめ

| | 問題点 | 解決策 |
| :--- | :--- | :--- |
| **送信側**<br/>(`page.tsx`) | Cookieの渡し方が不確実だった | Cookieを標準的な文字列形式に手動で構築して渡した |
| **受信側**<br/>(`route.ts`) | Cookieの読み取り方が不安定だった | Next.jsの標準API (`request.cookies`) を使って安定的に読み取るようにした |

この両輪の修正によって、サーバーサイドコンポーネントとAPIエンドポイント間の**認証の「握手」が初めて成功し**、データが正しく取得できるようになった、というわけです。




```dataviewjs
dv.header(3, "関連ノート");
var maxLoop = Math.min(dv.current().file.tags.length, 3);
for(let i=0;i<maxLoop;i++){
dv.span(dv.current().file.tags[i]);
dv.list(dv.pages(dv.current().file.tags[i]).sort(f=>f.file.mtime.ts,"desc").limit(15).file.link);
}

for (let outgo of dv.pages('outgoing([[' + dv.current().file.name + ']])')) {
    dv.header(4, outgo.file.name);
    dv.list(outgo.file.inlinks.sort());
}
```